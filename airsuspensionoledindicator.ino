#include <GyverOLED.h>
struct state
{    
  bool current;
  unsigned long prevTime;
  int pin;
};

state values[4];
GyverOLED<SSH1106_128x64> oled;
byte currentImage = 4;
byte readDelay = 100;

const uint8_t bitmap_1[] PROGMEM = {
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x00, 0x00, 0xC0, 0xFF, 0xFF, 0xFF, 0xC0, 0xE0, 0xFF, 0xFF, 0xFF, 0xC0, 0x00, 0x00, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x03, 0x00, 0x80, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0x80, 0x00, 0x03, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
	0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x07, 0x00, 0x00, 0x80, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x1C, 0x1C, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80, 0x00, 0x00, 0x07, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 
	0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xFF, 
};

const uint8_t bitmap_2[] PROGMEM = {
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x01, 0x00, 0xFF, 0xFF, 0xFF, 0xDF, 0xCF, 0x07, 0x03, 0x03, 0x07, 0xCF, 0xDF, 0xFF, 0xFF, 0xFF, 0x00, 0x01, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
	0xFF, 0x7F, 0x7F, 0x7F, 0x7F, 0xFF, 0x00, 0x00, 0x00, 0x07, 0xE7, 0x67, 0x67, 0x67, 0x66, 0x66, 0x66, 0x66, 0x67, 0x67, 0x67, 0xE7, 0x07, 0x00, 0x00, 0x00, 0xFF, 0x7F, 0x7F, 0x7F, 0x7F, 0xFF, 
	0xFF, 0xFE, 0xFE, 0xF0, 0xF0, 0xF3, 0xF0, 0xF0, 0xF0, 0xF0, 0xF3, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF3, 0xF0, 0xF0, 0xF0, 0xF0, 0xF3, 0xF0, 0xF0, 0xFE, 0xFE, 0xFF, 
};

const uint8_t bitmap_3[] PROGMEM = {
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x01, 0x00, 0xFF, 0xFF, 0xFF, 0xDF, 0xCF, 0x07, 0x03, 0x03, 0x07, 0xCF, 0xDF, 0xFF, 0xFF, 0xFF, 0x00, 0x01, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
	0xFF, 0x7F, 0x7F, 0x7F, 0x7F, 0xFF, 0x00, 0x00, 0x00, 0x07, 0xE7, 0x67, 0x67, 0x67, 0x66, 0x66, 0x66, 0x66, 0x67, 0x67, 0x67, 0xE7, 0x07, 0x00, 0x00, 0x00, 0xFF, 0x7F, 0x7F, 0x7F, 0x7F, 0xFF, 
	0xFF, 0xFE, 0xFE, 0xF0, 0xF0, 0xF3, 0xF0, 0xF0, 0xF0, 0xF0, 0xF3, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF3, 0xF0, 0xF0, 0xF0, 0xF0, 0xF3, 0xF0, 0xF0, 0xFE, 0xFE, 0xFF, 
};

const uint8_t bitmap_4[] PROGMEM = {
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07, 0x01, 0x00, 0xFF, 0xFF, 0xFF, 0xDF, 0xCF, 0x07, 0x03, 0x03, 0x07, 0xCF, 0xDF, 0xFF, 0xFF, 0xFF, 0x00, 0x01, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
	0xFF, 0x7F, 0x7F, 0x7F, 0x7F, 0xFF, 0x00, 0x00, 0x00, 0x07, 0xE7, 0x67, 0x67, 0x67, 0x66, 0x66, 0x66, 0x66, 0x67, 0x67, 0x67, 0xE7, 0x07, 0x00, 0x00, 0x00, 0xFF, 0x7F, 0x7F, 0x7F, 0x7F, 0xFF, 
	0xFF, 0xFE, 0xFE, 0xF0, 0xF0, 0xF3, 0xF0, 0xF0, 0xF0, 0xF0, 0xF3, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF3, 0xF0, 0xF0, 0xF0, 0xF0, 0xF3, 0xF0, 0xF0, 0xFE, 0xFE, 0xFF, 
};

void setup() {
  Serial.begin(9600);
  oled.init();  // инициализация
  oled.clear();   // очистить дисплей (или буфер)
  oled.update();  // обновить. Только для режима с буфером! OLED_BUFFER

  values[0].pin = A0;
  values[1].pin = A1;
  values[2].pin = A2;
  values[3].pin = A3;
  Serial.println("Started. Used pins: A0 - A3");

  pinMode(LED_BUILTIN, OUTPUT);
}

void loop() {
  unsigned long nowT = millis();
  for(int i = 0; i < 4; ++i)
  {    
    if(values[i].prevTime + readDelay >= nowT)
    {
      bool active = (float)analogRead(values[i].pin) * 5 / 1024 > 3;
      if(active != values[i].current)
      {
        values[i].current = active;
        values[i].prevTime = nowT;
        Serial.print("Pin A");
        Serial.print(i);
        Serial.print(" changed state to ");        
        Serial.println(active ? "true" : "false");        
      }
    }
  }

  byte stateImage = values[0].current ? 0 : 4;
  stateImage = values[1].current ? 1 : stateImage;
  stateImage = values[2].current ? 2 : stateImage;
  stateImage = values[3].current ? 3 : stateImage;

  if(currentImage != stateImage)
  {
    oled.clear();   // очистить дисплей (или буфер)
    oled.update();  // обновить. Только для режима с буфером! OLED_BUFFER

    switch(stateImage)
    {
      case 0:
        oled.drawBitmap(48, 16, bitmap_1, 32, 32, BITMAP_NORMAL, BUF_ADD);
        break;
      case 1:
        oled.drawBitmap(48, 16, bitmap_2, 32, 32, BITMAP_NORMAL, BUF_ADD);
        break;
      case 2:
        oled.drawBitmap(48, 16, bitmap_3, 32, 32, BITMAP_NORMAL, BUF_ADD);
        break;
      case 3:
        oled.drawBitmap(48, 16, bitmap_4, 32, 32, BITMAP_NORMAL, BUF_ADD);
        break;
    }

    if(stateImage < 4)
    {
      digitalWrite(LED_BUILTIN, HIGH);
    }
    else
    {
      digitalWrite(LED_BUILTIN, LOW);
    }

    currentImage = stateImage;
  }
}
